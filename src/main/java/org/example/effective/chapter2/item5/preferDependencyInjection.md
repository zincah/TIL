## ✅ 첫 번째: 생성자 주입 방식 (SpellCheckerV2)


✔ 장점

| 항목 | 설명 |
|---|---|
| 간단하고 명확함 | 주입되는 객체가 명시적으로 보이고 이해가 쉬움 |
| 초기화 시점에 객체 보장 | null 방지, 주입이 안 되면 컴파일 시점에 문제 발견 가능 |
| 테스트 용이 | 목 객체를 생성해서 바로 주입 가능 (new MockDictionary()) |
| 불변성 보장 용이 | final 필드로 선언하면 객체 생성 후 변경 불가 |

❌ 단점

| 항목                                            | 설명 |
|-----------------------------------------------|---|
| 지연 생성 불가                                      | 생성자 호출 시 객체가 바로 생성됨 (무거운 자원일 경우 부담) |
|  동일한 SpellChecker 여러 개 생성하려면 매번 Dictionary 필요 | 매번 new Dictionary() 해줘야 함 |


## ✅ 두 번째: Supplier 활용 방식 (SpellCheckerV3)

✔ 장점

| 항목                    | 설명 | 
|-----------------------|---|
| 지연 생성 가능              | checker가 내부적으로 dictionary.get()을 호출할 때까지 객체가 생성되지 않음 |
| 유연성 높음                | 다양한 Dictionary 구현을 상황에 따라 바꿔서 공급할 수 있음 |
| 테스트 시 다양한 조건 시뮬레이션 쉬움 | Supplier가 예외 던지거나 다른 동작 흉내 내기 쉬움 |
|  동적으로 객체 재생성 가능       | 여러 번 get() 하면 새로운 객체 공급 가능 (Stateless하게 설계되었다면) |

❌ 단점

| 항목           | 설명 |
|--------------|---|
| 복잡해 보일 수 있음  | 람다, 함수형 인터페이스 개념이 익숙하지 않으면 이해 어렵다 |
| 의존성이 눈에 덜 보임 | SpellCheckerV3 내부에서 언제 객체가 생성되는지 코드 없이는 알기 어려움 |
| 테스트 시 실수 가능성 | Supplier가 매번 새로운 객체를 리턴하면 상태 공유가 안 될 수도 있음 |